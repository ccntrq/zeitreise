#!/usr/bin/env perl
use v5.20;
use feature 'signatures';

use strict;
use warnings;
no warnings 'experimental::signatures';

use FindBin;
use IPC::Open3;
use Symbol;
use IO::Select;

my ($onto) = @ARGV;
zeitreise($onto);

exit 1;

sub zeitreise($onto) {

    die "need 'onto'" unless length $onto;

    # set editor.
    # this editor will mark all commits for 'edit'
    my $oldEditor =
      setEnv( 'GIT_SEQUENCE_EDITOR', $FindBin::Bin . '/zeitreise_editor edit' );
    my $out = gitExec( 'rebase', '-i', $onto );

    modifyLoop();

    setEnv( 'GIT_SEQUENCE_EDITOR', $oldEditor );

    return 1;
}

sub modifyLoop {
    my $status = checkStatus();
    return if $status->{status} ne 'rebasing';

    modifyCommit();
    sleep 1;    # to get a different timestamp for each commit

    my $out = gitExec( 'rebase', '--continue' );

    modifyLoop();
}

sub modifyCommit {

    my $date = `date`;
    chomp $date;

    my $oldEditor =
      setEnv( 'GIT_EDITOR', $FindBin::Bin . '/zeitreise_editor noop' );
    my $old_date = setEnv( 'GIT_COMMITTER_DATE', $date );

    my $out = gitExec( 'commit', '--amend', '--date', "'$date'", '-a' );

    setEnv( 'GIT_EDITOR',         $oldEditor );
    setEnv( 'GIT_COMMITTER_DATE', $old_date );

}

sub setEnv ( $key, $value ) {
    my $old = $ENV{$key};
    $ENV{$key} = $value;
    return $old;
}

sub checkStatus {

    my $out = gitExec('status');

    return statusParser($out);
}

sub statusParser($status) {
    my @status = split( "\n", $status );

    my $line = $status[0];

    # not in a rebase
    if ( $line =~ /^On branch (.*)$/ ) {
        return {
            status => 'normal',
            data   => {
                branch => $1,
            },
        };
    }

    # interactive rebase
    elsif ( $line =~ /^interactive rebase in progress; onto (.*)$/ ) {
        return {
            status => 'rebasing',
            data   => {
                onto => $1,
            },
        };

    }
    else {
        die "line: $line\nI'm confused. cannot parse 'status' output: $status";
    }
}

sub gitExec ( $cmd, @args ) {
    my @supportedCmds = qw(status rebase commit);

    die "command '$cmd' is not supported. supported are: '"
      . join( ', ', @supportedCmds ) . "'!"
      if !grep /$cmd/, @supportedCmds;

    my $fullCmd = "git $cmd " . ( scalar @args ? join( ' ', @args ) : '' );

    my ( $inH, $outH, $errH );
    $errH = gensym();

    my $gitPid = open3( $inH, $outH, $errH, $fullCmd )
      or die "failed to execute: $!";

    my $sel = IO::Select->new();
    $sel->add( $outH, $errH );

    my ( $out, $err );
    while ( my @ready = $sel->can_read ) {
        for my $fh (@ready) {
            my $line = <$fh>;
            if ( !defined $line ) {    # EOF
                $sel->remove($fh);
                next;
            }
            if ( $fh == $outH ) {
                $out .= $line;
            }
            elsif ( $fh == $errH ) {
                $err .= $line;
            }
            else {
                die "How did we get here?";
            }
        }
    }

    return $out;
}
